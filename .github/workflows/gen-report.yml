name: Generate report

on:
  workflow_call:
    inputs:
      project:
        required: true
        type: string
      jobset:
        required: true
        type: string
      nuke-cache:
        required: false
        type: string
        default: false

env:
  project: ${{ inputs.project }}
  jobset: ${{ inputs.jobset }}

jobs:
  get-cache-ids:
    name: Get cache IDs
    runs-on: ubuntu-latest

    # Wait for jobs for same report from previous workflow runs to finish.
    # Docs: https://docs.github.com/en/actions/using-jobs/using-concurrency
    concurrency: ${{ inputs.project }}:${{ inputs.jobset }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3

    - name: Install Nix
      uses: cachix/install-nix-action@v18
      with:
        extra_nix_config: |
          access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}

    # This steps gets/creates the IDs we reference when using the `cache` action in the next job:
    # * eval_id: the ID of the jobset evaluation we are generating the report for.
    # * success_eval_id: the ID of the last successful/finished evaluation of the jobset.
    # * unique_id: an ID that will be unique if the evaluation of the jobset is still in progress.
    - name: Get cache IDs
      run: |
        evalid=$(nix run .#jobset-latest-eval-id -- $project $jobset)
        successevalid=$(nix run .#jobset-latest-successful-eval-id -- $project $jobset)
        echo "eval_id=$evalid" >> $GITHUB_ENV
        echo "success_eval_id=$successevalid" >> $GITHUB_ENV
        if [ "$evalid" = 'null' ]; then
        echo "::warning::Could not retrieve evaluation ID for $project:$jobset jobset"
        elif [ "$evalid" = "$successevalid" ]; then
          echo "unique_id=success" >> $GITHUB_ENV
        else
          # Current Unix time.
          echo "unique_id=$(date '+%s')" >> $GITHUB_ENV
        fi

    outputs:
      eval-id: ${{ env.eval_id }}
      unique-id: ${{ env.unique_id }}

  generante-report:
    name: Generate report
    runs-on: ubuntu-latest
    needs: get-cache-ids
    env:
      eval_id: ${{ needs.get-cache-ids.outputs.eval-id }}
      unique_id: ${{ needs.get-cache-ids.outputs.unique-id }}

    # Don't run if we weren't able to get an ID for the latest evaluation of the jobset. This
    # usually happens if the jobset has never been evaluated.
    if: ${{ needs.get-cache-ids.outputs.eval-id != 'null' }}

    steps:
    # Always checkout the `master` branch so that we have the most up to date version of the repo
    # since other runs of this workflow might have pushed before we run.
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        ref: master

    - name: Install Nix
      uses: cachix/install-nix-action@v18
      with:
        extra_nix_config: |
          access-tokens = github.com=${{ secrets.GITHUB_TOKEN }}

    # Get the most up-to-date cache of the data/ directory containing Hydra build reports downloaded
    # by `nix-review-reports` for the jobset.
    #
    # The cache will not be updated at the end of the workflow run if the cache key is an exact
    # match. This means we want the key to always be unique if a jobset evaluation hasn't finished
    # so that the cache will be updated at the end of the workflow, so that subsequent runs of the
    # workflow don't need to re-download Hydra build reports that were downloaded during previous
    # workflow runs for this jobset.
    #
    # We should only ever get a exact hit on the key if a previous workflow generated a report for
    # this jobset evaluation after that evaluation finished/succeeded.
    #
    # When we don't get an exact hit we first try to restore the most recent cache for this jobset
    # evaluation, if there isn't a cache for this evaluation we restore the most recent cache for a
    # previous evaluation of this jobset.
    #
    # cache action docs:
    # https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows
    - name: Get cache
      uses: actions/cache@v3
      id: cache
      with:
        path: data
        key: ${{ env.project }}:${{ env.jobset }}-${{ env.eval_id }}-${{ env.unique_id }}
        restore-keys: |
          ${{ env.project }}:${{ env.jobset }}-${{ env.eval_id }}-
          ${{ env.project }}:${{ env.jobset }}-

    # Sometimes we may want to nuke the cache, like when builds were restarted on Hydra.
    - name: Nuke cache
      if: inputs.nuke-cache == 'true'
      run: |
        rm -rf data

    # Generate the report only if we don't have an exact cache hit. If we do have an exact cache hit
    # that means that we already generated a report for the jobset evaluation after the evaluation
    # succeeded/finished, and so the report is already up-to-date.
    #
    # After generating the report, we check if there are actually any substantial changes to push.
    # Example contents of `stats` array: `1 files changed, 230 insertions(+), 24628 deletions(-)`,
    # where `stats[3]` is `230` and `stats[5]` is `24628`.
    #
    # If both are equal to 1, this indicates that this was an update to a report for a jobset
    # evaluation that's still in progress, but that no additional queued builds completed since
    # the report was last generated, and so the only update to the report is an update to the
    # "Report built at ..." line. If that's the case, we don't commit and push that change.
    - name: Generate report
      id: gen-report
      if: steps.cache.outputs.cache-hit != 'true'
      run: |
        nix run . -- $project $jobset }}
        stats=($(git diff --shortstat))
        if [ "${stats[3]}" -eq 1 ] && [ "${stats[5]}" -eq 1 ]; then
          echo "push_changes=false" >> $GITHUB_ENV
        else
          echo "push_changes=true" >> $GITHUB_ENV
        fi

    # Push new/updated report only if we don't have an exact cache hit for the same reasons as
    # above, and if the report was updated and there were more changes then just an update to the
    # "Report built at ..." line.
    #
    # We need to pull and rebase before we push since another run of this workflow maybe have pushed
    # changes since we cloned the repo.
    - name: Push new/updated report
      if: steps.cache.outputs.cache-hit != 'true' && env.push_changes == 'true'
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com
        git add --all
        git commit -m "Add/update $project:$jobset report for eval $eval_id"
        until git push
        do
          git pull --rebase=true
        done
